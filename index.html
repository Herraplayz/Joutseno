<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Escape - A Horror Maze Game</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Creepster&amp;family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
<style>
:root {
    --primary-color: #c00;
    --dark-bg: #000;
    --light-text: #fff;
    --wall-color: #333;
    --path-color: #111;
    --water-color: #003366;
    --spike-color: #400;
}
body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: var(--dark-bg);
    font-family: 'Inter', sans-serif;
    color: var(--light-text);
    overflow: hidden;
}
.game-container {
    display: none;
    flex-direction: column;
    align-items: center;
    text-align: center;
    position: relative;
}
.game-ui {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1.5rem;
    pointer-events: none;
}
#level-display, #coin-display, #lives-display {
    font-family: 'Creepster', cursive;
    color: var(--primary-color);
    text-shadow: 0 0 5px var(--primary-color);
}
canvas {
    background-color: var(--path-color);
    border: 3px solid #444;
    border-radius: 10px;
    box-shadow: 0 0 30px rgba(204, 0, 0, 0.5);
    transition: width 0.5s, height 0.5s;
}
.screen {
    display: flex;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 10;
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
    background-color: var(--dark-bg);
}
#video-screen { display: flex; }
#intro-video-container {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
}
#intro-video {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}
#unmute-button {
    position: absolute;
    bottom: 100px;
    z-index: 12;
}
#skip-button { position: absolute; bottom: 30px; z-index: 11; }
#start-screen { display: none; }
#death-screen { display: none; background-color: rgba(0, 0, 0, 0.9); }
#death-image {
    max-width: 90%; max-height: 80%;
    width: auto; height: auto;
    border: 5px solid var(--primary-color);
    border-radius: 10px;
}
.button {
    padding: 15px 30px;
    font-size: 1.5rem;
    color: var(--light-text);
    background-color: var(--primary-color);
    border: 2px solid #ff5555;
    border-radius: 8px;
    cursor: pointer;
    font-family: 'Creepster', cursive;
    letter-spacing: 2px;
    transition: all 0.3s;
    margin-top: 20px;
    text-shadow: 0 0 5px #000;
}
.button:hover {
    background-color: #ff3333;
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(255, 51, 51, 0.4);
}
.button:disabled {
     background-color: #555;
     border-color: #777;
     cursor: not-allowed;
     transform: none;
     box-shadow: none;
}
@keyframes flash {
  0%, 100% { color: var(--primary-color); text-shadow: 0 0 10px #c00, 0 0 20px #c00; }
  50% { color: #ff4444; text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; }
}
@keyframes rotateWobble {
  0% { transform: rotate(-2.5deg); } 50% { transform: rotate(2.5deg); } 100% { transform: rotate(-2.5deg); }
}
#start-screen h2 {
     font-family: 'Creepster', cursive; font-size: 4rem; color: var(--primary-color);
     animation: flash 1.5s infinite, rotateWobble 5s infinite linear;
}
#start-screen p { font-size: 1.2rem; max-width: 600px; margin-bottom: 2rem; line-height: 1.6; }
#settings-menu {
    margin-top: 30px; background: #222; padding: 20px;
    border-radius: 10px; border: 1px solid #444;
}
#settings-menu label { font-size: 1.2rem; margin-right: 10px; }
#volume-slider { cursor: pointer; }

#shop-modal {
    display: none;
    position: fixed;
    z-index: 20;
    left: 0; top: 0; width: 100%; height: 100%;
    background-color: rgba(0,0,0,0.8);
    justify-content: center; align-items: center;
}
.shop-content {
    background: #1a1a1a;
    padding: 30px;
    border: 3px solid var(--primary-color);
    border-radius: 15px;
    width: 90%;
    max-width: 600px;
    text-align: center;
    position: relative;
    box-shadow: 0 0 40px rgba(204, 0, 0, 0.6);
}
.shop-content h2 {
    font-family: 'Creepster', cursive;
    font-size: 3rem;
    color: var(--primary-color);
    margin-top: 0;
}
#close-shop {
    position: absolute; top: 15px; right: 20px;
    font-size: 2rem; color: #fff;
    cursor: pointer; transition: color 0.3s;
}
#close-shop:hover { color: var(--primary-color); }
.shop-items {
    display: grid;
    grid-template-columns: 1fr;
    gap: 20px;
    margin-top: 20px;
}
.shop-item {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 10px;
    border: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.shop-item p { margin: 0; text-align: left; }
.shop-item .price { font-weight: bold; color: gold; }
.shop-item .buy-button { font-size: 1rem; padding: 10px 20px; margin: 0; }
</style>
</head>
<body>
<!-- Using a folder structure for assets as requested -->
<audio id="menu-music" loop=""><source src="assets/audio/veli.mp3" type="audio/mpeg"/></audio>
<audio id="bg-music" loop=""><source src="assets/audio/Sami_tulee.mp3" type="audio/mpeg"/></audio>
<audio id="key-sound"><source src="assets/audio/key-get.mp3" type="audio/mpeg"/></audio>
<audio id="level-up-sound"><source src="assets/audio/levelup.mp3" type="audio/mpeg"/></audio>
<audio id="splash-sound"><source src="assets/audio/blood.mp3" type="audio/mpeg"/></audio>
<audio id="spike-sound"><source src="assets/audio/spike.mp3" type="audio/mpeg"/></audio>
<audio id="coin-sound"><source src="assets/audio/coin.mp3" type="audio/mpeg"/></audio>
<audio id="powerup-sound"><source src="assets/audio/powerup-sound.mp3" type="audio/mpeg"/></audio>
<div class="screen" id="video-screen">
<div id="intro-video-container">
<!-- Replaced iframe with a video tag for better control -->
<video autoplay="" id="intro-video" muted="" playsinline="">
<source src="assets/images/ai_etta.mp4" type="video/mp4"/>
                Your browser does not support the video tag.
            </video>
</div>
<!-- Muted autoplay is required by most browsers. This button allows the user to enable sound. -->
<button class="button" id="unmute-button">Click to Enable Sound</button>
<button class="button" id="skip-button">Skip Intro</button>
</div>
<div class="screen" id="start-screen">
<h2>JOUTSENON KAUHU</h2>
<p>You are trapped in a dark, endless maze. A strange figure is hunting you. Find the key and get to the door to escape. Collect coins to buy power-ups. Use Arrow Keys or WASD to move.</p>
<button class="button" id="start-button">Start Game</button>
<button class="button" id="shop-button">Shop</button>
<div id="settings-menu">
<label for="volume-slider">Music Volume:</label>
<input id="volume-slider" max="1" min="0" step="0.1" type="range" value="0.5"/>
<button class="button" id="mute-button" style="font-size: 1rem; padding: 10px 15px;">Mute</button>
</div>
</div>
<div class="game-container">
<div class="game-ui">
<div id="level-display">Level: 1</div>
<div id="coin-display">ðŸ’°: 0</div>
</div>
<canvas id="gameCanvas"></canvas>
</div>
<div class="screen" id="death-screen">
<img alt="Game Over" id="death-image" src="assets/images/b3e178f7-351d-472a-8a07-90c9a7729f9f.png"/>
<button class="button" id="menu-button">Main Menu</button>
<button class="button" id="restart-button">Restart</button></div>
<div class="screen" id="shop-modal">
<div class="shop-content">
<span id="close-shop">Ã—</span>
<h2>Power-up Shop</h2>
<div class="shop-items">
<div id="shop-coin-display" style="font-size: 1.5rem; margin-bottom: 10px;">ðŸ’°: 0</div>
<div class="shop-item"><p><strong>Ghost Mode</strong> - Cost: 25 ðŸ’°</p><button class="button buy-button" id="buy-phase-button">Buy</button></div>
</div>
<div class="shop-item"><p>Bigger Maze - Cost: 10 ðŸ’°</p><button class="button buy-button" id="buy-size-button">Buy</button></div></div>
</div>

<script>
        // --- DOM Elements ---
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelDisplay = document.getElementById('level-display');
        const coinDisplay = document.getElementById('coin-display');
        const deathScreen = document.getElementById('death-screen');
        const restartButton = document.getElementById('restart-button');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.querySelector('.game-container');
        const videoScreen = document.getElementById('video-screen');
        const introVideo = document.getElementById('intro-video');
        const unmuteButton = document.getElementById('unmute-button');
        const skipButton = document.getElementById('skip-button');
        const shopButton = document.getElementById('shop-button');
        const shopModal = document.getElementById('shop-modal');
        const closeShopButton = document.getElementById('close-shop');
        const buyPhaseButton = document.getElementById('buy-phase-button');
        const buySizeButton = document.getElementById('buy-size-button');

        // --- Audio Elements ---
        const menuMusic = document.getElementById('menu-music');
        const bgMusic = document.getElementById('bg-music');
        const keySound = document.getElementById('key-sound');
        const levelUpSound = document.getElementById('level-up-sound');
        const splashSound = document.getElementById('splash-sound');
        const spikeSound = document.getElementById('spike-sound');
        const coinSound = document.getElementById('coin-sound');
        const powerupSound = document.getElementById('powerup-sound');
        const volumeSlider = document.getElementById('volume-slider');
        const muteButton = document.getElementById('mute-button');

        // --- Game State ---
        let level = 1;
        let gameOver = false;
        let gameStarted = false;
        let animationFrameId;
        let coins = parseInt(localStorage.getItem("coins") || "0");
        
        let powerups = {
            phaseCharges: 0,
        };

        // --- Maze and Tile Settings ---
        const tileSize = 40;
        let levelSize = { cols: 25, rows: 19 };
        let mapCols = levelSize.cols;
        let mapRows = levelSize.rows;
        let currentMap = [];
        let mapCoins = [];

        // --- Player ---
        const player = {
            x: 0, y: 0,
            width: tileSize * 0.7, height: tileSize * 0.7,
            speed: 3, originalSpeed: 3, hasKey: false
        };

        // --- Enemy ---
        const enemy = {
            x: 0, y: 0,
            width: tileSize * 0.8, height: tileSize * 0.8,
            speed: 1.5, path: [], pathUpdateCounter: 0, pathUpdateFrequency: 30
        };

        const key = { x: 0, y: 0, width: tileSize, height: tileSize, visible: true };
        const door = { x: 0, y: 0, width: tileSize, height: tileSize };
        const keys = { right: false, left: false, up: false, down: false };

        // --- Event Listeners ---
        document.addEventListener('keydown', keyDown);
        document.addEventListener('keyup', keyUp);
        if (restartButton) restartButton.addEventListener('click', restartGame);
        startButton.addEventListener('click', startGame);
        
        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value;
            bgMusic.volume = volume;
            menuMusic.volume = volume;
            introVideo.volume = volume;
        });
        
        muteButton.addEventListener('click', () => {
            const isMuted = !bgMusic.muted;
            bgMusic.muted = isMuted;
            menuMusic.muted = isMuted;
            muteButton.textContent = isMuted ? "Unmute" : "Mute";
        });
        
        function showStartScreen() {
            introVideo.pause();
            videoScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            menuMusic.volume = volumeSlider.value;
            
            // Ensure audio context is running
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.context.resume().catch(e => console.error("Tone.js context error:", e));
            }
            
            menuMusic.play().catch(e => console.error("Menu music play error:", e));
        }
        
        // --- Video Intro Listeners ---
        // --- Video Intro Listeners ---
function tryPlayIntro() {
    introVideo.muted = true;
    introVideo.play().catch(err => {
        console.warn("Autoplay blocked:", err);
        unmuteButton.style.display = 'block';
        skipButton.style.display = 'block';
    });
}

function showStartScreen() {
    introVideo.pause();
    videoScreen.style.display = 'none';
    startScreen.style.display = 'flex';
    menuMusic.volume = volumeSlider.value;
    if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
        Tone.context.resume().catch(e => console.error("Tone.js context error:", e));
    }
    menuMusic.play().catch(e => console.error("Menu music play error:", e));
}

skipButton.addEventListener('click', showStartScreen);

unmuteButton.addEventListener('click', () => {
    introVideo.muted = false;
    introVideo.play().catch(e => console.error("Video play error after unmute:", e));
    unmuteButton.style.display = 'none';
});

introVideo.addEventListener('ended', showStartScreen);

// Start intro attempt
tryPlayIntro();
        document.getElementById("menu-button").addEventListener("click", () => {
        deathScreen.style.display = "none";
        gameStarted = false;
        document.querySelector(".game-container").style.display = "none";
        startScreen.style.display = "flex";
        menuMusic.currentTime = 0;
        menuMusic.play();
        updateUI();
         });

        // Shop Listeners
        shopButton.addEventListener('click', () => shopModal.style.display = 'flex');
        closeShopButton.addEventListener('click', () => shopModal.style.display = 'none');
        buyPhaseButton.addEventListener('click', () => buyPowerup('phase'));
        if (buySizeButton) buySizeButton.addEventListener('click', () => buyPowerup('size'));

        function keyDown(e) {
            const key = e.key.toLowerCase();
            if (key === 'right' || key === 'arrowright' || key === 'd') keys.right = true;
            if (key === 'left' || key === 'arrowleft' || key === 'a') keys.left = true;
            if (key === 'up' || key === 'arrowup' || key === 'w') keys.up = true;
            if (key === 'down' || key === 'arrowdown' || key === 's') keys.down = true;
        }

        function keyUp(e) {
            const key = e.key.toLowerCase();
            if (key === 'right' || key === 'arrowright' || key === 'd') keys.right = false;
            if (key === 'left' || key === 'arrowleft' || key === 'a') keys.left = false;
            if (key === 'up' || key === 'arrowup' || key === 'w') keys.up = false;
            if (key === 'down' || key === 'arrowdown' || key === 's') keys.down = false;
        }
        
        function generateMaze(openness) {
            let map = Array(mapRows).fill(null).map(() => Array(mapCols).fill(1));
            let stack = [];
            let startCol = 1, startRow = 1;
            map[startRow][startCol] = 0;
            stack.push([startCol, startRow]);

            while (stack.length > 0) {
                let [cx, cy] = stack[stack.length - 1];
                let neighbors = [];
                [[0, -2], [0, 2], [-2, 0], [2, 0]].forEach(([dx, dy]) => {
                    let nx = cx + dx, ny = cy + dy;
                    if (nx > 0 && nx < mapCols - 1 && ny > 0 && ny < mapRows - 1 && map[ny][nx] === 1) {
                        neighbors.push([nx, ny]);
                    }
                });
                if (neighbors.length > 0) {
                    let [nx, ny] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    map[ny][nx] = 0;
                    map[cy + (ny - cy) / 2][cx + (nx - cx) / 2] = 0;
                    stack.push([nx, ny]);
                } else { stack.pop(); }
            }

            const wallsToRemove = (mapCols * mapRows) / openness;
            for (let i = 0; i < wallsToRemove; i++) {
                const randCol = Math.floor(Math.random() * (mapCols - 2)) + 1;
                const randRow = Math.floor(Math.random() * (mapRows - 2)) + 1;
                if(map[randRow][randCol] === 1) map[randRow][randCol] = 0;
            }
            
            return map;
        }

        // --- Drawing Functions ---
     function drawMaze() {
    const bloodPulse = 0.5 + Math.sin(Date.now()/500) * 0.25;
    const spikeFlicker = 0.8 + Math.sin(Date.now()/200) * 0.2;
    for (let row = 0; row < mapRows; row++) {
        for (let col = 0; col < mapCols; col++) {
            const tile = currentMap[row][col];
            const x = col * tileSize, y = row * tileSize;
            if (tile === 1) {
                const grad = ctx.createLinearGradient(x, y, x + tileSize, y + tileSize);
                grad.addColorStop(0, "#2a2a2a");
                grad.addColorStop(1, "#404040");
                ctx.fillStyle = grad;
                ctx.fillRect(x, y, tileSize, tileSize);
                ctx.strokeStyle = '#555';
                ctx.strokeRect(x, y, tileSize, tileSize);
            }
            else if (tile === 2) {
                ctx.fillStyle = '#220000';
                ctx.fillRect(x, y, tileSize, tileSize);
                ctx.fillStyle = `rgba(255,0,0,${spikeFlicker})`;
                ctx.shadowColor = "#ff3333";
                ctx.shadowBlur = 10 * spikeFlicker;
                for(let i = 0; i < 4; i++){
                    ctx.beginPath();
                    ctx.moveTo(x + (i * 10) + 2, y + 38);
                    ctx.lineTo(x + (i * 10) + 5, y + 5);
                    ctx.lineTo(x + (i * 10) + 8, y + 38);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
            else if (tile === 3) {
                ctx.fillStyle = `rgba(102,0,0,${0.7 + bloodPulse*0.3})`;
                ctx.beginPath();
                ctx.arc(x + tileSize/2, y + tileSize/2, tileSize/2.2, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = '#990000';
                ctx.stroke();
            }
        }
    }
}

        function drawCoins() {
            ctx.font = `${tileSize * 0.6}px Arial`;
            ctx.fillStyle = 'gold';
            ctx.textAlign = 'center';
            for (const coin of mapCoins) {
                ctx.fillText('ðŸ’°', coin.x + tileSize / 2, coin.y + tileSize / 1.5);
            }
        }

        function drawPlayer() {
            ctx.fillStyle = powerups.phaseCharges > 0 ? '#00ffff' : '#0099db';
            ctx.shadowColor = powerups.phaseCharges > 0 ? '#00ffff' : '#0099db';
            ctx.shadowBlur = 15;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.shadowBlur = 0;
            if (player.hasKey) {
                ctx.fillStyle = 'gold';
                ctx.font = '20px Arial';
                ctx.fillText('ðŸ”‘', player.x + player.width/2, player.y - 5);
            }
        }

        function drawEnemy() {
            ctx.fillStyle = '#e0e0e0';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 20;
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#5a2d0c';
            for (let i = 0; i < enemy.height; i += 8) {
                ctx.fillRect(enemy.x, enemy.y + i, enemy.width, 4);
            }
            const headSize = enemy.width * 0.8;
            ctx.fillStyle = '#ffdab9';
            ctx.fillRect(enemy.x + (enemy.width - headSize) / 2, enemy.y - headSize * 0.8, headSize, headSize);
            ctx.fillStyle = '#654321';
            ctx.fillRect(enemy.x + (enemy.width - headSize) / 2, enemy.y - headSize * 0.8, headSize, headSize / 2);
        }

        function drawKey() {
            if (key.visible) {
                ctx.fillStyle = 'gold';
                ctx.font = `${tileSize * 0.8}px Arial`;
                ctx.fillText('ðŸ”‘', key.x, key.y + tileSize * 0.8);
            }
        }

        function drawDoor() {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(door.x, door.y, door.width, door.height);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(door.x + door.width - 10, door.y + door.height / 2, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- Game Logic ---
        function getGridPos(x, y) { return { col: Math.floor(x / tileSize), row: Math.floor(y / tileSize) }; }
        function getTileAt(col, row) {
             if (col < 0 || col >= mapCols || row < 0 || row >= mapRows) return 1;
            return currentMap[row][col];
        }

        function isWallCollision(x, y, width, height) {
            const corners = [ {x: x, y: y}, {x: x + width, y: y}, {x: x, y: y + height}, {x: x + width, y: y + height} ];
            for(const corner of corners) {
                const grid = getGridPos(corner.x, corner.y);
                if(getTileAt(grid.col, grid.row) === 1) {
                    if (powerups.phaseCharges > 0) {
                        powerups.phaseCharges--;
                        currentMap[grid.row][grid.col] = 0; // Break the wall
                        return false; // No collision this time
                    }
                    return true;
                }
            }
            return false;
        }

        function updatePlayer() {
            let nextX = player.x, nextY = player.y;
            if (keys.right) nextX += player.speed;
            if (keys.left) nextX -= player.speed;
            if (keys.up) nextY -= player.speed;
            if (keys.down) nextY += player.speed;
            if (!isWallCollision(nextX, player.y, player.width, player.height)) player.x = nextX;
            if (!isWallCollision(player.x, nextY, player.width, player.height)) player.y = nextY;

            const playerCenterGrid = getGridPos(player.x + player.width / 2, player.y + player.height / 2);
            const currentTile = getTileAt(playerCenterGrid.col, playerCenterGrid.row);

            if (currentTile === 2) { spikeSound.play(); endGame(); }
            else if (currentTile === 3) {
                if (player.speed === player.originalSpeed) splashSound.play();
                player.speed = player.originalSpeed * 0.5;
            } else { player.speed = player.originalSpeed; }
        }

        function findPath(start, end) {
            const openList = [], closedList = [], grid = [];
            for (let row = 0; row < mapRows; row++) {
                grid[row] = [];
                for (let col = 0; col < mapCols; col++) {
                    grid[row][col] = { x: col, y: row, f: 0, g: 0, h: 0, parent: null, isWall: getTileAt(col, row) === 1 };
                }
            }
            const startNode = grid[start.row][start.col], endNode = grid[end.row][end.col];
            openList.push(startNode);
            while (openList.length > 0) {
                let lowestIndex = 0;
                for (let i = 1; i < openList.length; i++) if (openList[i].f < openList[lowestIndex].f) lowestIndex = i;
                const currentNode = openList[lowestIndex];
                if (currentNode === endNode) {
                    const path = []; let temp = currentNode;
                    while (temp.parent) { path.push(temp); temp = temp.parent; }
                    return path.reverse();
                }
                openList.splice(lowestIndex, 1);
                closedList.push(currentNode);
                const neighbors = [];
                const x = currentNode.x, y = currentNode.y;
                if (grid[y - 1] && grid[y - 1][x]) neighbors.push(grid[y - 1][x]);
                if (grid[y + 1] && grid[y + 1][x]) neighbors.push(grid[y + 1][x]);
                if (grid[y] && grid[y][x - 1]) neighbors.push(grid[y][x - 1]);
                if (grid[y] && grid[y][x + 1]) neighbors.push(grid[y][x + 1]);
                for (const neighbor of neighbors) {
                    if (closedList.includes(neighbor) || neighbor.isWall) continue;
                    const gScore = currentNode.g + 1; let gScoreIsBest = false;
                    if (!openList.includes(neighbor)) {
                        gScoreIsBest = true;
                        neighbor.h = Math.abs(neighbor.x - endNode.x) + Math.abs(neighbor.y - endNode.y);
                        openList.push(neighbor);
                    } else if (gScore < neighbor.g) gScoreIsBest = true;
                    if (gScoreIsBest) { neighbor.parent = currentNode; neighbor.g = gScore; neighbor.f = neighbor.g + neighbor.h; }
                }
            }
            return [];
        }

        function updateEnemy() {
            enemy.pathUpdateCounter++;
            const playerPos = getGridPos(player.x + player.width / 2, player.y + player.height / 2);
            const enemyPos = getGridPos(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);

            if (enemy.pathUpdateCounter >= enemy.pathUpdateFrequency || enemy.path.length === 0) {
                enemy.pathUpdateCounter = 0;
                if (playerPos.col !== enemyPos.col || playerPos.row !== enemyPos.row) {
                     enemy.path = findPath(enemyPos, playerPos);
                }
            }
            
            if (enemy.path.length > 0) {
                const nextStep = enemy.path[0];
                const targetX = nextStep.x * tileSize + (tileSize - enemy.width) / 2;
                const targetY = nextStep.y * tileSize + (tileSize - enemy.height) / 2;
                const dx = targetX - enemy.x, dy = targetY - enemy.y, distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 1) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                } else { enemy.path.shift(); }
            }
        }

        function checkCollisions() {
            // Player vs Enemy
            if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x && player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                endGame();
                return;
            }

            const playerGrid = getGridPos(player.x + player.width / 2, player.y + player.height / 2);

            // Player vs Key
            const keyGrid = getGridPos(key.x, key.y);
            if (key.visible && playerGrid.col === keyGrid.col && playerGrid.row === keyGrid.row) {
                player.hasKey = true; key.visible = false; keySound.play();
            }

            // Player vs Door
            const doorGrid = getGridPos(door.x, door.y);
            if (player.hasKey && playerGrid.col === doorGrid.col && playerGrid.row === doorGrid.row) {
                levelUp();
                return;
            }

            // Player vs Coins
            for (let i = mapCoins.length - 1; i >= 0; i--) {
                const coin = mapCoins[i];
                const coinGrid = getGridPos(coin.x, coin.y);
                if (playerGrid.col === coinGrid.col && playerGrid.row === coinGrid.row) {
                    coins++;
                    coinSound.play();
                    updateUI();
                    mapCoins.splice(i, 1);
                }
            }
        }
        
        function setupLevel() {
            if (level >= 5) { levelSize.cols = 29; levelSize.rows = 23; }
            mapCols = levelSize.cols;
            mapRows = levelSize.rows;
            canvas.width = mapCols * tileSize;
            canvas.height = mapRows * tileSize;
            
            updateUI();
            const openness = (level % 2 === 0) ? 4 : 8;
            currentMap = generateMaze(openness); 
            mapCoins = [];

            const placeObject = (obj) => {
                let col, row;
                do {
                    col = Math.floor(Math.random() * (mapCols - 2)) + 1;
                    row = Math.floor(Math.random() * (mapRows - 2)) + 1;
                } while (getTileAt(col,row) !== 0);
                if(obj) {
                    obj.x = col * tileSize + (tileSize - obj.width) / 2;
                    obj.y = row * tileSize + (tileSize - obj.height) / 2;
                }
                return {col, row};
            }

            // Place coins
            const numCoins = 3 + Math.floor(level / 2) + Math.floor((levelSize.cols * levelSize.rows) / 200);
            for (let i = 0; i < numCoins; i++) {
                const pos = placeObject(null);
                mapCoins.push({ x: pos.col * tileSize, y: pos.row * tileSize });
            }

            player.x = 1 * tileSize + (tileSize - player.width) / 2;
            player.y = 1 * tileSize + (tileSize - player.height) / 2;
            
            let enemyPos;
            do { enemyPos = placeObject(enemy); } while (Math.abs(1 - enemyPos.col) + Math.abs(1 - enemyPos.row) < 15)

            // Place the key and store its grid position
            const keyGridPos = placeObject(key);
            key.visible = true;

            door.x = (mapCols - 2) * tileSize;
            door.y = (mapRows - 2) * tileSize;
            currentMap[mapRows-2][mapCols-2] = 0;
            currentMap[mapRows-3][mapCols-2] = 0;
            currentMap[mapRows-2][mapCols-3] = 0;

            const obstaclesToAdd = Math.floor((mapCols * mapRows) / 50);
            for (let i = 0; i < obstaclesToAdd; i++) {
                let randCol, randRow;
                let isTooClose;
                do {
                    randCol = Math.floor(Math.random() * (mapCols - 2)) + 1;
                    randRow = Math.floor(Math.random() * (mapRows - 2)) + 1;
                    
                    const isNearPlayer = Math.abs(randCol - 1) + Math.abs(randRow - 1) < 5;
                    const isNearKey = Math.abs(randCol - keyGridPos.col) + Math.abs(randRow - keyGridPos.row) < 5;
                    const isNearDoor = Math.abs(randCol - (mapCols - 2)) + Math.abs(randRow - (mapRows - 2)) < 5;
                    isTooClose = isNearPlayer || isNearKey || isNearDoor;

                } while(getTileAt(randCol, randRow) !== 0 || isTooClose);
                
                currentMap[randRow][randCol] = (Math.random() > 0.6) ? 2 : 3;
            }

            player.hasKey = false;
            enemy.speed = 1.2 + (level * 0.05);
            player.speed = player.originalSpeed;
            enemy.path = [];
            enemy.pathUpdateCounter = 0;
        }

        function levelUp() {
            level++;
            coins += 5; // Bonus coins for completing a level
            levelUpSound.play();
            if (level > 20) {
                alert("You escaped! For now...");
                restartGame(true); // Full reset
                return;
            }
            setupLevel();
        }

        function updateUI() {
            levelDisplay.textContent = `Level: ${level}`;
            coinDisplay.textContent = `ðŸ’°: ${coins}`;
            document.getElementById("shop-coin-display").textContent = `ðŸ’°: ${coins}`;
            localStorage.setItem("coins", coins);
            buyPhaseButton.disabled = coins < 25;
            buySizeButton.disabled = coins < 10;
        }
        buySizeButton.textContent = "Buy";
    bgMusic.currentTime = 0;
    bgMusic.play().catch(e => console.error("Music play error:", e));
    setupLevel();
    mainLoop();
;
            buySizeButton.textContent = "Buy";
            bgMusic.currentTime = 0;
            bgMusic.play();
            setupLevel();
            mainLoop();
        
        function buyPowerup(type) {
            let cost = 0;
            let canBuy = false;
            switch(type) {
                
                case 'phase':
                    cost = 25;
                    if (coins >= cost) {
                        powerups.phaseCharges++;
                        canBuy = true;
                    }
                    break;
                case 'size':
                    cost = 10;
                    if (coins >= cost) {
                        levelSize.cols += 4;
                        levelSize.rows += 4;
                        canBuy = true;
                        // Disable after one purchase for balance
                        buySizeButton.textContent = "Purchased";
                        buySizeButton.disabled = true;
                    }
                    break;
            }

            if (canBuy) {
                coins -= cost;
                powerupSound.play();
                updateUI();
            }
        }

        function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

        function mainLoop() {
            if (gameOver) return;
            clearCanvas();
            drawMaze();
            drawDoor();
            drawKey();
            drawCoins();
            drawPlayer();
            drawEnemy();
            updatePlayer();
            updateEnemy();
            checkCollisions();
            animationFrameId = requestAnimationFrame(mainLoop);
        }

        
function startGame() {
    gameContainer.style.display = 'flex';
    startScreen.style.display = 'none';
    // Stop menu music completely
    menuMusic.pause();
    menuMusic.currentTime = 0;
    // Start level background music
    bgMusic.currentTime = 0;
    bgMusic.play().catch(e => console.error("Music play error:", e));
    initGame();
}

function endGame() {
    localStorage.setItem("coins", coins);
    gameOver = true;
    bgMusic.pause();
    cancelAnimationFrame(animationFrameId);
    deathScreen.style.display = 'flex';
}

// Restart game function (only one definition now)
function restartGame(fullReset = false) {
    deathScreen.style.display = 'none';
    gameOver = false;
    level = 1;

    if (fullReset) {
        coins = 0;
        localStorage.setItem("coins", coins);
    } else {
        // Load saved coins
        coins = parseInt(localStorage.getItem("coins") || "0");
    }

    powerups.phaseCharges = 0;
    levelSize = { cols: 25, rows: 19 };
    buySizeButton.textContent = "Buy";

    bgMusic.currentTime = 0;
    bgMusic.play().catch(e => console.error("Music play error:", e));
    setupLevel();
    mainLoop();
}

function initGame() {
    player.hasKey = false;
    gameOver = false;
    keys.right = keys.left = keys.up = keys.down = false;
    coins = parseInt(localStorage.getItem("coins") || "0");
    currentMap = generateMaze(8);
    setupLevel();
    gameStarted = true;
    player.speed = player.originalSpeed;
    bgMusic.currentTime = 0;
    bgMusic.play().catch(e => console.error("Music play error:", e));
    mainLoop();
}


</script>
</body>
</html>
